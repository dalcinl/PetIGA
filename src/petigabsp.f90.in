! -*- f90 -*-

pure subroutine NewtonCotesPoints(n,U0,U1,X)
  use PetIGA
  implicit none
  integer(kind=IGA_INTEGER_KIND), intent(in)  :: n
  real   (kind=IGA_REAL_KIND   ), intent(in)  :: U0, U1
  real   (kind=IGA_REAL_KIND   ), intent(out) :: X(0:n-1)
  integer(kind=IGA_INTEGER_KIND)  :: i

  do i = 0, n-1
     X(i) = U0 + i * (U1-U0)/(n-1)
  end do

end subroutine NewtonCotesPoints


pure subroutine GaussLobattoPoints(n,U0,U1,X)
  use PetIGA
  implicit none
  integer(kind=IGA_INTEGER_KIND), intent(in)  :: n
  real   (kind=IGA_REAL_KIND   ), intent(in)  :: U0, U1
  real   (kind=IGA_REAL_KIND   ), intent(out) :: X(0:n-1)
  integer, parameter :: rk = IGA_REAL_KIND

  select case (n)
  case (2)
     X(0) = -1.0_rk
     X(1) = -X(0)
  case (3)
     X(0) = -1.0_rk
     X(1) =  0.0_rk
     X(2) = -X(0)
  case (4)
     X(0) = -1.0_rk
     X(1) = -0.447213595499957939281834733746255247_rk
     X(2) = -X(1)
     X(3) = -X(0)
  case (5)
     X(0) = -1.0_rk
     X(1) = -0.654653670707977143798292456246858356_rk
     X(2) =  0.0_rk
     X(3) = -X(1)
     X(4) = -X(0)
  case (6)
     X(0) = -1.0_rk
     X(1) = -0.765055323929464692851002973959338150_rk
     X(2) = -0.285231516480645096314150994040879072_rk
     X(3) = -X(2)
     X(4) = -X(1)
     X(5) = -X(0)
  case (7)
     X(0) = -1.0_rk
     X(1) = -0.830223896278566929872032213967465140_rk
     X(2) = -0.468848793470714213803771881908766329_rk
     X(3) =  0.0_rk
     X(4) = -X(2)
     X(5) = -X(1)
     X(6) = -X(0)
  case (8)
     X(0) = -1.0_rk
     X(1) = -0.871740148509606615337445761220663438_rk
     X(2) = -0.591700181433142302144510731397953190_rk
     X(3) = -0.209299217902478868768657260345351255_rk
     X(4) = -X(3)
     X(5) = -X(2)
     X(6) = -X(1)
     X(7) = -X(0)
  case (9)
     X(0) = -1.0_rk
     X(1) = -0.899757995411460157312345244418337958_rk
     X(2) = -0.677186279510737753445885427091342451_rk
     X(3) = -0.363117463826178158710752068708659213_rk
     X(4) =  0.0_rk
     X(5) = -X(3)
     X(6) = -X(2)
     X(7) = -X(1)
     X(8) = -X(0)
  case default
     X = 0.0_rk
  end select

  X = (X + 1) * (U1-U0)/2 + U0;

end subroutine GaussLobattoPoints


pure subroutine LagrangeBasisFunsDers(xx,p,d,X,B)
  use PetIGA
  implicit none
  integer(kind=IGA_INTEGER_KIND), intent(in)  :: p, d
  real   (kind=IGA_REAL_KIND   ), intent(in)  :: xx
  real   (kind=IGA_REAL_KIND   ), intent(in)  :: X(0:p)
  real   (kind=IGA_REAL_KIND   ), intent(out) :: B(0:3,0:p)
  integer(kind=IGA_INTEGER_KIND)  :: m, i, j, k, l
  real   (kind=IGA_REAL_KIND   )  :: Lp, Ls1, Ls2, Ls3

  do m = 0, p
     Lp = 1
     do i = 0, p
        if (i == m) cycle
        Lp = Lp * (xx-X(i))/(X(m)-X(i))
     end do
     B(0,m) = Lp
  end do

  if (d < 1) return
  do m = 0, p
     Ls1 = 0
     do j = 0, p
        if (j == m) cycle
        Lp = 1
        do i = 0, p
           if (i == m .or. i == j) cycle
           Lp = Lp * (xx-X(i))/(X(m)-X(i))
        end do
        Ls1 = Ls1 + Lp/(X(m)-X(j))
     end do
     B(1,m) = Ls1
  end do

  if (d < 2) return
  do m = 0, p
     Ls2 = 0
     do k = 0, p
        if (k == m) cycle
        Ls1 = 0
        do j = 0, p
           if (j == m .or. j == k) cycle
           Lp = 1
           do i = 0, p
              if (i == m .or. i == k .or. i == j) cycle
              Lp = Lp * (xx-X(i))/(X(m)-X(i))
           end do
           Ls1 = Ls1 + Lp/(X(m)-X(j))
        end do
        Ls2 = Ls2 + Ls1/(X(m)-X(k))
     end do
     B(2,m) = Ls2
  end do

  if (d < 3) return
  do m = 0, p
     Ls3 = 0
     do l = 0, p
        if (l == m) cycle
        Ls2 = 0
        do k = 0, p
           if (k == m .or. k == l) cycle
           Ls1 = 0
           do j = 0, p
              if (j == m .or. j == l .or. j == k) cycle
              Lp = 1
              do i = 0, p
                 if (i == m .or. i == l .or. i == k .or. i == j) cycle
                 Lp = Lp * (xx-X(i))/(X(m)-X(i))
              end do
              Ls1 = Ls1 + Lp/(X(m)-X(j))
           end do
           Ls2 = Ls2 + Ls1/(X(m)-X(k))
        end do
        Ls3 = Ls3 + Ls2/(X(m)-X(l))
     end do
     B(3,m) = Ls3
  end do

end subroutine LagrangeBasisFunsDers
